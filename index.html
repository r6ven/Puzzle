<!DOCTYPE html><html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>50 ParÃ§alÄ± Puzzle Oyunu</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #444; }
    #congrats {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      opacity: 0;
      font-size: 2rem;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      pointer-events: none;
      z-index: 10;
    }
    .show {
      animation: showAnim 1s forwards;
    }
    @keyframes showAnim {
      0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      60%  { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
  </style>
</head>
<body>
  <div id="congrats">Seni Ã§ok seviyorum ðŸ’–</div>
  <script>
    const config = { type: Phaser.AUTO, width: 360, height: 900, backgroundColor: '#333', parent: document.body, scene: { preload, create } };
    new Phaser.Game(config);function preload() {
  this.load.image('puzzle', '1000156285.jpg');
}

function drawPieceShape(ctx, w, h, top, right, bottom, left) {
  const b = Math.min(w, h) / 4;
  ctx.beginPath();
  ctx.moveTo(left ? b : 0, 0);
  ctx.lineTo(w / 2 - b, 0);
  ctx.arc(w / 2, 0, b, Math.PI, 0, top);
  ctx.lineTo(w - (right ? b : 0), 0);
  ctx.lineTo(w, h / 2 - b);
  ctx.arc(w, h / 2, b, -Math.PI / 2, Math.PI / 2, right);
  ctx.lineTo(w, h - (bottom ? b : 0));
  ctx.lineTo(w / 2 + b, h);
  ctx.arc(w / 2, h, b, 0, Math.PI, bottom);
  ctx.lineTo(left ? b : 0, h);
  ctx.lineTo(0, h / 2 + b);
  ctx.arc(0, h / 2, b, Math.PI / 2, -Math.PI / 2, left);
  ctx.lineTo(0, top ? b : 0);
  ctx.closePath();
}

function create() {
  const img = this.textures.get('puzzle').getSourceImage();
  const frameX = 10, frameY = 10;
  const frameW = config.width - 20;
  const scale = frameW / img.width;
  const frameH = img.height * scale;

  // Ã‡erÃ§eve
  const graphics = this.add.graphics();
  graphics.lineStyle(4, 0xffffff);
  graphics.strokeRect(frameX, frameY, frameW, frameH);

  const cols = 10, rows = 5;
  const pwOrig = img.width / cols, phOrig = img.height / rows;
  const pw = frameW / cols, ph = frameH / rows;
  const pieces = [];
  const startY = frameY + frameH + 20;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // ParÃ§a baÄŸlantÄ± durumlarÄ±
      const top = r > 0 ? !( (r - 1) % 2 === 0 ) : false;
      const bottom = r % 2 === 0;
      const left = c > 0 ? !( (c - 1) % 2 === 0 ) : false;
      const right = c % 2 === 0;

      // Puzzle parÃ§asÄ±
      const idx = r * cols + c;
      const cv = document.createElement('canvas');
      cv.width = pw;
      cv.height = ph;
      const ctx = cv.getContext('2d');
      drawPieceShape(ctx, pw, ph, top, right, bottom, left);
      ctx.clip('evenodd');
      ctx.drawImage(img,
        c * pwOrig, r * phOrig, pwOrig, phOrig,
        0, 0, pw, ph
      );
      this.textures.addCanvas('piece' + idx, cv);

      // ParÃ§a izi (outline)
      const cv2 = document.createElement('canvas');
      cv2.width = pw;
      cv2.height = ph;
      const ctx2 = cv2.getContext('2d');
      drawPieceShape(ctx2, pw, ph, top, right, bottom, left);
      ctx2.lineWidth = 2;
      ctx2.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx2.stroke();
      this.textures.addCanvas('outline' + idx, cv2);

      const correctX = frameX + c * pw + pw / 2;
      const correctY = frameY + r * ph + ph / 2;
      this.add.image(correctX, correctY, 'outline' + idx).setDisplaySize(pw, ph);

      // KarÄ±ÅŸÄ±k baÅŸlangÄ±Ã§ pozisyonu
      const rndX = Phaser.Math.Between(pw / 2, config.width - pw / 2);
      const rndY = Phaser.Math.Between(startY, config.height - ph / 2);
      const spr = this.add.image(rndX, rndY, 'piece' + idx)
                    .setInteractive()
                    .setDisplaySize(pw, ph);
      this.input.setDraggable(spr);
      pieces.push({ spr, correctX, correctY });
    }
  }

  // Drag & drop ve tamamlama kontrolÃ¼
  this.input.on('drag', (pointer, gameObject, dragX, dragY) => {
    gameObject.x = dragX;
    gameObject.y = dragY;
  });
  this.input.on('dragend', () => {
    const done = pieces.every(p => Phaser.Math.Distance.Between(
      p.spr.x, p.spr.y, p.correctX, p.correctY
    ) < 20);
    if (done) document.getElementById('congrats').classList.add('show');
  });
}

  </script>
</body>
</html>