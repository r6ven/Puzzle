<!DOCTYPE html><html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>50 ParÃ§alÄ± Puzzle Oyunu</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #444; }
    #congrats {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      opacity: 0;
      font-size: 2rem;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      pointer-events: none;
      z-index: 10;
    }
    .show {
      animation: showAnim 1s forwards;
    }
    @keyframes showAnim {
      0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      60%  { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
  </style>
</head>
<body>
  <div id="congrats">Seni Ã§ok seviyorum ðŸ’–</div>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: 360,
      height: 800,
      backgroundColor: '#333',
      parent: document.body,
      scene: { preload, create }
    };
    new Phaser.Game(config);function preload() {
  this.load.image('puzzle', '1000156285.jpg');
}

function drawPieceShape(ctx, w, h) {
  const bump = Math.min(w, h) / 4;
  ctx.beginPath();
  ctx.moveTo(bump, 0);
  ctx.lineTo(w - bump, 0);
  ctx.arc(w / 2, 0, bump, Math.PI, 0, true);
  ctx.lineTo(w, bump);
  ctx.lineTo(w, h - bump);
  ctx.arc(w, h / 2, bump, Math.PI * 1.5, Math.PI * 0.5, true);
  ctx.lineTo(w - bump, h);
  ctx.lineTo(bump, h);
  ctx.arc(w / 2, h, bump, 0, Math.PI, true);
  ctx.lineTo(0, h - bump);
  ctx.lineTo(0, bump);
  ctx.arc(0, h / 2, bump, Math.PI * 0.5, Math.PI * 1.5, true);
  ctx.closePath();
}

function create() {
  const img = this.textures.get('puzzle').getSourceImage();
  const frameX = 20, frameY = 20;
  const frameW = config.width - 40;
  const scale = frameW / img.width;
  const frameH = img.height * scale;

  // Ã‡erÃ§eve
  const graphics = this.add.graphics();
  graphics.lineStyle(4, 0xffffff);
  graphics.strokeRect(frameX, frameY, frameW, frameH);

  const cols = 10, rows = 5;
  const pwOrig = img.width / cols, phOrig = img.height / rows;
  const pw = frameW / cols, ph = frameH / rows;
  const pieces = [];
  const startY = frameY + frameH + 20;
  const gap = 5;

  let idx = 0;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // Canvas ile parÃ§a oluÅŸturma
      const cv = document.createElement('canvas');
      cv.width = pwOrig; cv.height = phOrig;
      const ctx = cv.getContext('2d');
      drawPieceShape(ctx, pwOrig, phOrig);
      ctx.clip();
      ctx.drawImage(img,
        c * pwOrig, r * phOrig, pwOrig, phOrig,
        0, 0, pwOrig, phOrig
      );
      this.textures.addCanvas('piece' + idx, cv);

      // BaÅŸlangÄ±Ã§ konumu: hizalÄ± grid altÄ±nda
      const arrX = frameX + (idx % cols) * (pw + gap) + pw / 2;
      const arrY = startY + Math.floor(idx / cols) * (ph + gap) + ph / 2;
      const spr = this.add.image(arrX, arrY, 'piece' + idx)
                    .setInteractive()
                    .setDisplaySize(pw, ph);
      this.input.setDraggable(spr);

      // DoÄŸru pozisyon
      const correctX = frameX + c * pw + pw / 2;
      const correctY = frameY + r * ph + ph / 2;
      pieces.push({ spr, correctX, correctY });
      idx++;
    }
  }

  // Drag & drop
  this.input.on('drag', (pointer, gameObject, dragX, dragY) => {
    gameObject.x = dragX;
    gameObject.y = dragY;
  });
  this.input.on('dragend', () => {
    const done = pieces.every(p => Phaser.Math.Distance.Between(
      p.spr.x, p.spr.y, p.correctX, p.correctY
    ) < 20);
    if (done) document.getElementById('congrats').classList.add('show');
  });
}

  </script>
</body>
</html>